"""Unit tests for services."""

import pytest
from pathlib import Path
from unittest.mock import AsyncMock, patch

from src.storage import LocalStorageBackend
from src.services.ingestion import IngestionService
from src.services.ingestion.service import IngestionInput
from src.services.compliance import ComplianceGuard
from src.services.compliance.service import ComplianceInput


@pytest.mark.asyncio
class TestIngestionService:
    """Tests for the ingestion service."""

    async def test_ingest_valid_apk(self, temp_dir, sample_apk):
        """Test ingesting a valid APK.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
            sample_apk: Sample APK file fixture for testing.
        """
        storage = LocalStorageBackend(temp_dir)
        service = IngestionService(storage)
        
        input_data = IngestionInput(apk_path=sample_apk)
        result = await service.ingest(input_data)
        
        assert result.success
        assert result.data is not None
        assert result.data.apk_metadata.provenance.sha256_hash is not None
        assert result.data.normalized_apk_path is not None

    async def test_ingest_nonexistent_file(self, temp_dir):
        """Test ingesting a non-existent file.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
        """
        storage = LocalStorageBackend(temp_dir)
        service = IngestionService(storage)
        
        input_data = IngestionInput(apk_path=Path("/nonexistent/app.apk"))
        result = await service.ingest(input_data)
        
        assert not result.success
        assert "not found" in result.error.lower()

    async def test_ingest_invalid_file(self, temp_dir):
        """Test ingesting an invalid file.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
        """
        storage = LocalStorageBackend(temp_dir)
        service = IngestionService(storage)
        
        # Create a non-APK file
        invalid_file = temp_dir / "invalid.apk"
        invalid_file.write_text("not an apk")
        
        input_data = IngestionInput(apk_path=invalid_file)
        result = await service.ingest(input_data)
        
        assert not result.success


@pytest.mark.asyncio
class TestComplianceGuard:
    """Tests for the compliance guard service."""

    async def test_check_clean_code(self, temp_dir):
        """Test compliance check with clean code.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
        """
        storage = LocalStorageBackend(temp_dir)
        guard = ComplianceGuard(storage)
        
        input_data = ComplianceInput(
            run_id="test_run",
            apk_hash="abc123" * 10,
            generated_files={
                "HomeScreen.kt": """
                package com.example.app
                
                import androidx.compose.runtime.Composable
                
                @Composable
                fun HomeScreen() {
                    Text("Hello, World!")
                }
                """,
            },
        )
        
        result = await guard.check(input_data)
        
        assert result.success
        assert result.data.compliance_report.passed

    async def test_check_suspicious_patterns(self, temp_dir):
        """Test compliance check with suspicious patterns.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
        """
        storage = LocalStorageBackend(temp_dir)
        guard = ComplianceGuard(storage)
        
        input_data = ComplianceInput(
            run_id="test_run",
            apk_hash="abc123" * 10,
            generated_files={
                "Suspicious.kt": """
                // This code was generated by JADX
                /* jadx decompiler */
                package com.example.app
                """,
            },
        )
        
        result = await guard.check(input_data)
        
        assert result.success
        # Should have warnings for suspicious patterns
        report = result.data.compliance_report
        assert len(report.violations) > 0

    async def test_calculate_similarity(self, temp_dir):
        """Test code similarity calculation.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
        """
        storage = LocalStorageBackend(temp_dir)
        guard = ComplianceGuard(storage)
        
        # Identical code should have high similarity
        code1 = "fun hello() { println(\"hello\") }"
        code2 = "fun hello() { println(\"hello\") }"
        
        similarity = guard._calculate_similarity(code1, code2)
        assert similarity > 0.9
        
        # Very different code should have lower similarity
        code3 = """
        class CompletelyDifferent {
            private val items = mutableListOf<String>()
            
            fun addItem(item: String) {
                items.add(item)
            }
            
            fun removeItem(item: String) {
                items.remove(item)
            }
        }
        """
        similarity = guard._calculate_similarity(code1, code3)
        assert similarity < 0.7

    async def test_suspicious_pattern_detection(self, temp_dir):
        """Test suspicious pattern detection.

        Args:
            temp_dir: Temporary directory fixture for test isolation.
        """
        storage = LocalStorageBackend(temp_dir)
        guard = ComplianceGuard(storage)
        
        clean_code = "fun hello() { }"
        suspicious_code = "/* JADX INFO: Access modifiers changed */"
        
        clean_patterns = guard._check_suspicious_patterns(clean_code)
        suspicious_patterns = guard._check_suspicious_patterns(suspicious_code)
        
        assert len(clean_patterns) == 0
        assert len(suspicious_patterns) > 0
